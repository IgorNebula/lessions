/* eslint-disable prefer-const */
/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * ### Extending Interfaces
 *В TypeScript вы можете
 *расширить интерфейс, создав новый интерфейс, который наследует
 *Из исходного интерфейса с помощью ключевого слова «Extends».
 *Новый интерфейс может включать в себя дополнительные свойства, методы,
 *или переопределить членов исходного интерфейса.
 */
interface Shape {
  width: number;
  height: number;
}

interface Square extends Shape {
  sideLength: number;
}

let square: Square = {
  sideLength: 0,
  width: 0,
  height: 0,
};
// В этом примере квадратный интерфейс расширяет форму
// интерфейс и добавляет дополнительную сторону свойства.
// переменная квадрата типа должна иметь все свойства
// как в форме, так и в квадратных интерфейсах.

/**
 * ### Interface Declaration
 *Интерфейс в TypeScript - это план для создания объектов
 *с конкретной структурой.Интерфейс определяет набор свойств,
 *Методы и события, которые должны реализовать класс или объект.
 *Интерфейс - это контракт между объектами и классами и
 *Может использоваться для обеспечения соблюдения конкретной структуры для объектов в вашем коде.
 *Вот пример объявления интерфейса в TypeScript:
 */
interface Person {
  firstName: string;
  lastName: string;
  age: number;

  getFullName(): string;
}

// В этом примере интерфейс человека определяет четыре свойства:
// FirstName, Lastname, Age и метод getFullName ().
// Возрастное свойство необязательно, обозначенное?символ.
// Любой класс или объект, который реализует интерфейс человека, должен
// иметь эти свойства и метод.

/**
 * Hybrid Types
 *
 */
type StringOrNumber = string | number;
// Вы также можете использовать гибридные типы для создания более сложных типов
// это может представлять собой комбинацию нескольких различных типов
// значений.Например:
type Education = {
  degree: string;
  school: string;
  yesar: number;
};

type Usergibrid = {
  name: string;
  age: number;
  email: string;
  education: Education;
};
/**
 * Пример: гибридный тип объект-функция
 * В данном примере интерфейс Logger представляет собой смесь
 * двух типов функций: одни из них принимают сообщения
 *  в качествае аргументов, а другие - нет. Кроме того,
 *  он предоставляет свойство с именем level и метод с
 * именем setLevel
 */
interface Logger {
  (message: string): void; // объект реализующий этот интерфейс,так же должен поддерживать вызов себя как функции.
  level: string;
  setLevel(newLevel: string): void;
}

function createLogger(): Logger {
  let logger = function (message: string) {
    //свойство-функция принимающая в параметры сообщение
    console.log(`[${logger.level}] ${message}`); //вывод в консоль: уровень и сообщение описанных в интерфейсе
  } as Logger; // утверждение типа указывающее компилятору что, эта функция реализация интерфейса "логгер"

  logger.level = "info"; //устанавливаем начальный уровень лога в инфо
  //Метод для изменения текущего уровня логгера
  logger.setLevel = function (newLevel: string) {
    //переменной "логгер" назначаем анонимную функцию с параметром " новый уровень"
    logger.level = newLevel; // в атрибут "левел" переменной "логгер", записываем параметр "новый уровень" из анонимной функции
  };
  return logger; //возвращаем созданную переменную типа "Логгер"
}
